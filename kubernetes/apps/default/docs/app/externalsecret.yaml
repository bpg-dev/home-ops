---
# yaml-language-server: $schema=https://kubernetes-schemas.pages.dev/external-secrets.io/externalsecret_v1.json
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: docs-config
spec:
  secretStoreRef:
    kind: ClusterSecretStore
    name: onepassword
  target:
    name: docs-config
    creationPolicy: Owner
    template:
      engineVersion: v2
      data:
        # Django configurations (django-configurations)
        # Docs uses django-configurations; explicitly set the settings module + configuration class.
        # This avoids unintentionally enabling development-only apps like django_extensions.
        DJANGO_SETTINGS_MODULE: impress.settings
        # Use Production config so Django ALLOWED_HOSTS is enforced and read from env.
        # (Base has ALLOWED_HOSTS empty, which triggers DisallowedHost 400s behind Envoy.)
        DJANGO_CONFIGURATION: Production

        # Host validation (Django ALLOWED_HOSTS is a list; the project uses django-configurations values.ListValue)
        # Comma-separated list.
        # With tcpSocket probes, we don't need to allow Pod-IP Host headers; keep this tight.
        ALLOWED_HOSTS: "docs.${SECRET_DOMAIN}"
        # django-configurations uses an environ prefix by default, so some settings may read from
        # DJANGO_* variables. The backend's Production config reads allowed hosts using
        # values.ListValue(..., environ_name="ALLOWED_HOSTS") without environ_prefix=None.
        # Provide both forms to avoid DisallowedHost 400s behind Envoy.
        DJANGO_ALLOWED_HOSTS: "docs.${SECRET_DOMAIN}"

        # Post-login redirect (mozilla-django-oidc)
        # If LOGIN_REDIRECT_URL is unset, the backend ends up with None and the OIDC callback can 500
        # when it tries to resolve_url(None). Set both forms (raw + DJANGO_ prefixed) for safety.
        LOGIN_REDIRECT_URL: /home/
        DJANGO_LOGIN_REDIRECT_URL: /home/

        # Database configuration
        DB_HOST: postgres-rw.postgresql-system.svc.cluster.local
        DB_PORT: "5432"
        DB_NAME: "{{ .DOCS_DB_NAME }}"
        DB_USER: "{{ .DOCS_DB_USER }}"
        DB_PASSWORD: "{{ .DOCS_DB_PASSWORD }}"
        # Redis configuration
        REDIS_URL: redis://dragonfly.dragonfly-system:6379/1
        DJANGO_CELERY_BROKER_URL: redis://dragonfly.dragonfly-system:6379/1
        # OIDC configuration (Authentik)
        # Note: Configure an OIDC provider in Authentik with slug "docs" and use the client ID/secret below
        # The application slug in Authentik should be "docs" to match these endpoints
        # Redirect URI in Authentik should be:
        # - https://docs.${SECRET_DOMAIN}/api/v1.0/callback/
        # (Docs uses mozilla-django-oidc under the /api/v1.0/ prefix: /authenticate/ -> /callback/)
        # Authentik OpenID configuration:
        # - issuer is slugged (…/application/o/docs/)
        # - authorize/token/userinfo are NOT slugged (…/application/o/{authorize,token,userinfo}/)
        # - jwks and end-session are slugged (…/application/o/docs/{jwks,end-session}/)
        OIDC_OP_JWKS_ENDPOINT: https://sso.${SECRET_DOMAIN}/application/o/docs/jwks/
        OIDC_OP_AUTHORIZATION_ENDPOINT: https://sso.${SECRET_DOMAIN}/application/o/authorize/
        OIDC_OP_TOKEN_ENDPOINT: https://sso.${SECRET_DOMAIN}/application/o/token/
        OIDC_OP_USER_ENDPOINT: https://sso.${SECRET_DOMAIN}/application/o/userinfo/
        OIDC_OP_LOGOUT_ENDPOINT: https://sso.${SECRET_DOMAIN}/application/o/docs/end-session/
        OIDC_RP_CLIENT_ID: "{{ .DOCS_OIDC_CLIENT_ID }}"
        OIDC_RP_CLIENT_SECRET: "{{ .DOCS_OIDC_CLIENT_SECRET }}"
        OIDC_RP_SIGN_ALGO: RS256
        # Include `profile` so the IdP can return display name / username claims consistently.
        OIDC_RP_SCOPES: "openid email profile"
        # S3 configuration (Garage)
        AWS_ACCESS_KEY_ID: "{{ .S3_ACCESS_KEY_ID }}"
        AWS_SECRET_ACCESS_KEY: "{{ .S3_SECRET_ACCESS_KEY }}"
        # Also provide the env var names used by the Django settings in the backend image.
        AWS_S3_ACCESS_KEY_ID: "{{ .S3_ACCESS_KEY_ID }}"
        AWS_S3_SECRET_ACCESS_KEY: "{{ .S3_SECRET_ACCESS_KEY }}"
        AWS_STORAGE_BUCKET_NAME: docs-media
        AWS_S3_ENDPOINT_URL: https://s3.${SECRET_DOMAIN}
        AWS_S3_REGION_NAME: us-east-1
        # Django secret key
        # Upstream docs refer to DJANGO_SECRET_KEY; we also keep SECRET_KEY for compatibility.
        DJANGO_SECRET_KEY: "{{ .DOCS_SECRET_KEY }}"
        SECRET_KEY: "{{ .DOCS_SECRET_KEY }}"

        # Admin bootstrap (used by the chart's createsuperuser Job)
        # Add these fields to the 1Password "docs" item:
        # - DOCS_SUPERUSER_EMAIL
        # - DOCS_SUPERUSER_PASSWORD
        DJANGO_SUPERUSER_EMAIL: "{{ .DOCS_SUPERUSER_EMAIL }}"
        DJANGO_SUPERUSER_PASSWORD: "{{ .DOCS_SUPERUSER_PASSWORD }}"
  dataFrom:
    - extract:
        key: docs
  refreshInterval: 30m

---
# Superuser credentials to bootstrap the database/user for Docs
apiVersion: external-secrets.io/v1
kind: ExternalSecret
metadata:
  name: docs-postgres-superuser
spec:
  secretStoreRef:
    kind: ClusterSecretStore
    name: onepassword
  target:
    name: docs-postgres-superuser
    creationPolicy: Owner
    template:
      type: kubernetes.io/basic-auth
      engineVersion: v2
      data:
        # Map 1Password field names to expected secret key names
        username: "{{ index . \"superuser-username\" }}"
        password: "{{ index . \"superuser-password\" }}"
  # Extract all fields from the postgres item in 1Password
  dataFrom:
    - extract:
        key: postgres
  refreshInterval: 30m

